# This file is autogenerated. Do not edit it by hand. Regenerate it with:
#   srb rbi gems

# typed: true
#
# If you would like to make changes to this file, great! Please create the gem's shim here:
#
#   https://github.com/sorbet/sorbet-typed/new/master?filename=lib/yard/all/yard.rbi
#
# yard-0.9.20
module YARD
  def self.load_plugins; end
  def self.parse(*args); end
  def self.parse_string(*args); end
  def self.ruby18?; end
  def self.ruby19?; end
  def self.ruby2?; end
  def self.windows?; end
end
module YARD::Server
  def self.register_static_path(path); end
end
class Object < BasicObject
  def P(namespace, name = nil, type = nil); end
  def log; end
end
module YARD::CLI
end
module YARD::CodeObjects
  extend YARD::CodeObjects::NamespaceMapper
end
module YARD::Handlers
end
module YARD::Handlers::Common
end
module YARD::Handlers::C
end
module YARD::Handlers::Ruby
end
module YARD::Handlers::Ruby::Legacy
end
module YARD::I18n
end
module YARD::Parser
end
module YARD::Parser::C
end
module YARD::Parser::Ruby
end
module YARD::Parser::Ruby::Legacy
end
module YARD::Rake
end
module YARD::Serializers
end
module YARD::Server::Commands
end
module YARD::Tags
end
module YARD::Templates
end
module YARD::Templates::Helpers
end
module YARD::Templates::Helpers::Markup
end
class YARD::Config
  def self.add_ignored_plugins_file; end
  def self.arguments; end
  def self.load; end
  def self.load_autoload_plugins; end
  def self.load_commandline_plugins; end
  def self.load_commandline_safemode; end
  def self.load_gem_plugins; end
  def self.load_plugin(name); end
  def self.load_plugin_failed(name, exception); end
  def self.load_plugins; end
  def self.options; end
  def self.options=(arg0); end
  def self.read_config_file; end
  def self.save; end
  def self.translate_plugin_name(name); end
  def self.translate_plugin_names; end
  def self.with_yardopts; end
end
class String
  def shell_split; end
end
class Module
  def class_name; end
end
class Array
  def place(*values); end
end
class SymbolHash < Hash
  def [](key); end
  def []=(key, value); end
  def delete(key); end
  def has_key?(key); end
  def initialize(symbolize_value = nil); end
  def key?(key); end
  def merge!(hash); end
  def merge(hash); end
  def self.[](*hsh); end
  def update(hash); end
end
class Insertion
  def after(val, recursive = nil); end
  def after_any(val); end
  def before(val, recursive = nil); end
  def before_any(val); end
  def initialize(list, value); end
  def insertion(val, rel, recursive = nil, list = nil); end
end
class File < IO
  def self.cleanpath(path, rel_root = nil); end
  def self.empty?(arg0); end
  def self.open!(file, *args, &block); end
  def self.relative_path(from, to); end
end
module Gem
  def self.source_index; end
end
class Gem::SourceIndex
  def ==(other); end
  def add_spec(gem_spec, name = nil); end
  def add_specs(*gem_specs); end
  def all_gems; end
  def dump; end
  def each(&block); end
  def find_name(gem_name, requirement = nil); end
  def gem_signature(gem_full_name); end
  def gems; end
  def index_signature; end
  def initialize(specifications = nil); end
  def latest_specs(include_prerelease = nil); end
  def length; end
  def load_gems_in(*spec_dirs); end
  def outdated; end
  def prerelease_gems; end
  def prerelease_specs; end
  def refresh!; end
  def released_gems; end
  def released_specs; end
  def remove_spec(full_name); end
  def search(gem_pattern, platform_only = nil); end
  def self.from_gems_in(*spec_dirs); end
  def self.from_installed_gems(*deprecated); end
  def self.installed_spec_directories; end
  def self.load_specification(file_name); end
  def size; end
  def spec_dirs; end
  def spec_dirs=(arg0); end
  def specification(full_name); end
  include Enumerable
end
class YARD::Options
  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def delete(key); end
  def each; end
  def inspect; end
  def merge(opts); end
  def method_missing(meth, *args, &block); end
  def reset_defaults; end
  def self.default_attr(key, default); end
  def to_hash; end
  def update(opts); end
end
class YARD::Templates::TemplateOptions < YARD::Options
  def __globals; end
  def default_return; end
  def default_return=(arg0); end
  def embed_mixins; end
  def embed_mixins=(arg0); end
  def embed_mixins_match?(mixin); end
  def format; end
  def format=(arg0); end
  def globals; end
  def globals=(arg0); end
  def hide_void_return; end
  def hide_void_return=(arg0); end
  def highlight; end
  def highlight=(arg0); end
  def index; end
  def index=(arg0); end
  def markup; end
  def markup=(arg0); end
  def markup_provider; end
  def markup_provider=(arg0); end
  def no_highlight; end
  def no_highlight=(value); end
  def object; end
  def object=(arg0); end
  def owner; end
  def owner=(arg0); end
  def page_title; end
  def page_title=(arg0); end
  def serialize; end
  def serialize=(arg0); end
  def serializer; end
  def serializer=(arg0); end
  def template; end
  def template=(arg0); end
  def type; end
  def type=(arg0); end
  def verifier; end
  def verifier=(arg0); end
end
class YARD::CLI::Command
  def common_options(opts); end
  def description; end
  def load_script(file); end
  def parse_options(opts, args); end
  def self.run(*args); end
  def unrecognized_option(err); end
end
class YARD::CLI::YardoptsCommand < YARD::CLI::Command
  def initialize; end
  def options_file; end
  def options_file=(arg0); end
  def parse_arguments(*args); end
  def parse_rdoc_document_file(file = nil); end
  def parse_yardopts(file = nil); end
  def parse_yardopts_options(*args); end
  def support_rdoc_document_file!(file = nil); end
  def use_document_file; end
  def use_document_file=(arg0); end
  def use_yardopts_file; end
  def use_yardopts_file=(arg0); end
  def yardopts(file = nil); end
  def yardopts_options(opts); end
end
class YARD::CLI::YardocOptions < YARD::Templates::TemplateOptions
  def file; end
  def file=(arg0); end
  def files; end
  def files=(arg0); end
  def format; end
  def format=(arg0); end
  def index; end
  def index=(arg0); end
  def item; end
  def item=(arg0); end
  def locale; end
  def locale=(arg0); end
  def objects; end
  def objects=(arg0); end
  def onefile; end
  def onefile=(arg0); end
  def readme; end
  def readme=(arg0); end
  def serializer; end
  def serializer=(arg0); end
  def title; end
  def title=(arg0); end
  def verifier; end
  def verifier=(arg0); end
end
class YARD::CLI::Yardoc < YARD::CLI::YardoptsCommand
  def add_api_verifier; end
  def add_extra_files(*files); end
  def add_tag(tag_data, factory_method = nil); end
  def add_visibility_verifier; end
  def all_objects; end
  def apis; end
  def apis=(arg0); end
  def apply_locale; end
  def assets; end
  def assets=(arg0); end
  def copy_assets; end
  def description; end
  def excluded; end
  def excluded=(arg0); end
  def extra_file_valid?(file, check_exists = nil); end
  def fail_on_warning; end
  def fail_on_warning=(arg0); end
  def files; end
  def files=(arg0); end
  def general_options(opts); end
  def generate; end
  def generate=(arg0); end
  def has_markup; end
  def has_markup=(arg0); end
  def hidden_apis; end
  def hidden_apis=(arg0); end
  def hidden_tags; end
  def hidden_tags=(arg0); end
  def initialize; end
  def list; end
  def list=(arg0); end
  def options; end
  def optparse(*args); end
  def output_options(opts); end
  def parse_arguments(*args); end
  def parse_files(*files); end
  def print_list; end
  def run(*args); end
  def run_generate(checksums); end
  def run_verifier(list); end
  def save_yardoc; end
  def save_yardoc=(arg0); end
  def statistics; end
  def statistics=(arg0); end
  def tag_options(opts); end
  def use_cache; end
  def use_cache=(arg0); end
  def verify_markup_options; end
  def visibilities; end
  def visibilities=(arg0); end
end
class YARD::Tags::Directive
  def after_parse; end
  def call; end
  def expanded_text; end
  def expanded_text=(arg0); end
  def handler; end
  def initialize(tag, parser); end
  def object; end
  def parser; end
  def parser=(arg0); end
  def tag; end
  def tag=(arg0); end
end
class YARD::Tags::EndGroupDirective < YARD::Tags::Directive
  def call; end
end
class YARD::Tags::GroupDirective < YARD::Tags::Directive
  def call; end
end
class YARD::Tags::MacroDirective < YARD::Tags::Directive
  def anonymous?; end
  def attach?; end
  def call; end
  def class_method?; end
  def expand(macro_data); end
  def find_or_create; end
  def new?; end
  def warn; end
end
class YARD::Tags::MethodDirective < YARD::Tags::Directive
  def after_parse; end
  def call; end
  def create_object; end
  def method_name; end
  def method_signature; end
  def sanitized_tag_signature; end
  def use_indented_text; end
end
class YARD::Tags::AttributeDirective < YARD::Tags::MethodDirective
  def after_parse; end
  def create_attribute_data(object); end
  def method_name; end
  def method_signature; end
  def readable?; end
  def writable?; end
end
class YARD::Tags::ParseDirective < YARD::Tags::Directive
  def call; end
end
class YARD::Tags::ScopeDirective < YARD::Tags::Directive
  def call; end
end
class YARD::Tags::VisibilityDirective < YARD::Tags::Directive
  def call; end
end
class YARD::Tags::Tag
  def explain_types; end
  def initialize(tag_name, text, types = nil, name = nil); end
  def name; end
  def name=(arg0); end
  def object; end
  def object=(arg0); end
  def tag_name; end
  def tag_name=(arg0); end
  def text; end
  def text=(arg0); end
  def type; end
  def types; end
  def types=(arg0); end
end
class YARD::Tags::OverloadTag < YARD::Tags::Tag
  def docstring; end
  def has_tag?(name); end
  def initialize(tag_name, text); end
  def is_a?(other); end
  def kind_of?(other); end
  def method_missing(*args, &block); end
  def name(prefix = nil); end
  def object=(value); end
  def parameters; end
  def parse_signature; end
  def parse_tag(text); end
  def signature; end
  def tag(name); end
  def tags(name = nil); end
  def type; end
end
class YARD::Tags::Library
  def abstract_tag(text); end
  def api_tag(text); end
  def attr_reader_tag(text); end
  def attr_tag(text); end
  def attr_writer_tag(text); end
  def attribute_directive(tag, parser); end
  def author_tag(text); end
  def deprecated_tag(text); end
  def directive_call(tag, parser); end
  def directive_create(tag_name, tag_buf, parser); end
  def endgroup_directive(tag, parser); end
  def example_tag(text); end
  def factory; end
  def factory=(arg0); end
  def group_directive(tag, parser); end
  def has_directive?(tag_name); end
  def has_tag?(tag_name); end
  def initialize(factory = nil); end
  def macro_directive(tag, parser); end
  def method_directive(tag, parser); end
  def note_tag(text); end
  def option_tag(text); end
  def overload_tag(text); end
  def param_tag(text); end
  def parse_directive(tag, parser); end
  def private_tag(text); end
  def raise_tag(text); end
  def return_tag(text); end
  def scope_directive(tag, parser); end
  def see_tag(text); end
  def self.default_factory; end
  def self.default_factory=(factory); end
  def self.define_directive(tag, tag_meth = nil, directive_class = nil); end
  def self.define_tag(label, tag, meth = nil); end
  def self.directive_method_name(tag_name); end
  def self.factory_method_for(tag); end
  def self.factory_method_for_directive(directive); end
  def self.instance; end
  def self.labels; end
  def self.sorted_labels; end
  def self.tag_method_name(tag_name); end
  def self.tag_or_directive_method_name(tag_name, type = nil); end
  def self.transitive_tags; end
  def self.transitive_tags=(arg0); end
  def self.visible_tags; end
  def self.visible_tags=(arg0); end
  def send_to_factory(tag_name, meth, text); end
  def since_tag(text); end
  def tag_create(tag_name, tag_buf); end
  def todo_tag(text); end
  def version_tag(text); end
  def visibility_directive(tag, parser); end
  def yield_tag(text); end
  def yieldparam_tag(text); end
  def yieldreturn_tag(text); end
end
module YARD::Registry
  def self.[](path); end
  def self.all(*types); end
  def self.at(path); end
  def self.checksum_for(data); end
  def self.checksums; end
  def self.clear; end
  def self.delete(object); end
  def self.delete_from_disk; end
  def self.each(&block); end
  def self.global_yardoc_file(spec, for_writing = nil); end
  def self.instance; end
  def self.load!(file = nil); end
  def self.load(files = nil, reparse = nil); end
  def self.load_all; end
  def self.load_yardoc(file = nil); end
  def self.local_yardoc_file(spec, for_writing = nil); end
  def self.locale(name); end
  def self.lock_for_writing(file = nil, &block); end
  def self.locked_for_writing?(file = nil); end
  def self.old_global_yardoc_file(spec, for_writing = nil); end
  def self.partial_resolve(namespace, name, type = nil); end
  def self.paths(reload = nil); end
  def self.po_dir; end
  def self.po_dir=(dir); end
  def self.proxy_types; end
  def self.register(object); end
  def self.resolve(namespace, name, inheritance = nil, proxy_fallback = nil, type = nil); end
  def self.root; end
  def self.save(merge = nil, file = nil); end
  def self.single_object_db; end
  def self.single_object_db=(v); end
  def self.thread_local_resolver; end
  def self.thread_local_store; end
  def self.thread_local_store=(value); end
  def self.yardoc_file; end
  def self.yardoc_file=(v); end
  def self.yardoc_file_for_gem(gem, ver_require = nil, for_writing = nil); end
  extend Enumerable
end
class YARD::RegistryStore
  def [](key); end
  def []=(key, value); end
  def all_disk_objects; end
  def checksums; end
  def checksums_path; end
  def delete(key); end
  def destroy(force = nil); end
  def file; end
  def get(key); end
  def initialize; end
  def keys(reload = nil); end
  def load!(file = nil); end
  def load(file = nil); end
  def load_all; end
  def load_checksums; end
  def load_locale(name); end
  def load_object_types; end
  def load_proxy_types; end
  def load_root; end
  def load_yardoc; end
  def load_yardoc_old; end
  def locale(name); end
  def lock_for_writing(file = nil, &block); end
  def locked_for_writing?(file = nil); end
  def object_types_path; end
  def objects_path; end
  def paths_for_type(type, reload = nil); end
  def proxy_types; end
  def proxy_types_path; end
  def put(key, value); end
  def root; end
  def save(merge = nil, file = nil); end
  def values(reload = nil); end
  def values_for_type(type, reload = nil); end
  def write_checksums; end
  def write_complete_lock; end
  def write_object_types; end
  def write_proxy_types; end
end
module YARD::CodeObjects::NamespaceMapper
  def clear_separators; end
  def default_separator(value = nil); end
  def register_separator(sep, *valid_types); end
  def self.default_separator; end
  def self.default_separator=(arg0); end
  def self.invalidate; end
  def self.map; end
  def self.map_match; end
  def self.rev_map; end
  def separators; end
  def separators_for_type(type); end
  def separators_match; end
  def types_for_separator(sep); end
end
class YARD::CodeObjects::CodeObjectList < Array
  def <<(value); end
  def initialize(owner = nil); end
  def push(value); end
end
class YARD::CodeObjects::Base
  def ==(other); end
  def [](key); end
  def []=(key, value); end
  def add_file(file, line = nil, has_comments = nil); end
  def add_tag(*tags); end
  def base_docstring; end
  def copy_to(other); end
  def copyable_attributes; end
  def docstring(locale = nil); end
  def docstring=(comments); end
  def dynamic; end
  def dynamic=(arg0); end
  def dynamic?; end
  def eql?(other); end
  def equal?(other); end
  def file; end
  def files; end
  def format(options = nil); end
  def format_source(source); end
  def group; end
  def group=(arg0); end
  def has_tag?(name); end
  def hash; end
  def initialize(namespace, name, *arg2); end
  def inspect; end
  def line; end
  def method_missing(meth, *args, &block); end
  def name(prefix = nil); end
  def namespace; end
  def namespace=(obj); end
  def parent; end
  def parent=(obj); end
  def path; end
  def relative_path(other); end
  def root?; end
  def self.===(other); end
  def self.new(namespace, name, *args, &block); end
  def sep; end
  def signature; end
  def signature=(arg0); end
  def source; end
  def source=(statement); end
  def source_type; end
  def source_type=(arg0); end
  def tag(name); end
  def tags(name = nil); end
  def title; end
  def to_ary; end
  def to_s; end
  def translate_docstring(locale); end
  def type; end
  def visibility; end
  def visibility=(v); end
end
class YARD::CodeObjects::NamespaceObject < YARD::CodeObjects::Base
  def aliases; end
  def attributes; end
  def child(opts = nil); end
  def children; end
  def class_attributes; end
  def class_mixins; end
  def constants(opts = nil); end
  def cvars; end
  def groups; end
  def groups=(arg0); end
  def included_constants; end
  def included_meths(opts = nil); end
  def initialize(namespace, name, *args, &block); end
  def instance_attributes; end
  def instance_mixins; end
  def meths(opts = nil); end
  def mixins(*scopes); end
end
class YARD::CodeObjects::ModuleObject < YARD::CodeObjects::NamespaceObject
  def inheritance_tree(include_mods = nil); end
end
class YARD::CodeObjects::RootObject < YARD::CodeObjects::ModuleObject
  def equal?(other); end
  def hash; end
  def inspect; end
  def path; end
  def root?; end
  def title; end
end
class YARD::DocstringParser
  def call_after_parse_callbacks; end
  def call_directives_after_parse; end
  def create_directive(tag_name, tag_buf); end
  def create_ref_tag(tag_name, name, object_name); end
  def create_tag(tag_name, tag_buf = nil); end
  def detect_reference(content); end
  def directives; end
  def directives=(arg0); end
  def handler; end
  def handler=(arg0); end
  def initialize(library = nil); end
  def library; end
  def library=(arg0); end
  def namespace; end
  def object; end
  def object=(arg0); end
  def parse(content, object = nil, handler = nil); end
  def parse_content(content); end
  def post_process; end
  def raw_text; end
  def raw_text=(arg0); end
  def reference; end
  def reference=(arg0); end
  def self.after_parse(&block); end
  def self.after_parse_callbacks; end
  def state; end
  def state=(arg0); end
  def tag_is_directive?(tag_name); end
  def tags; end
  def tags=(arg0); end
  def text; end
  def text=(arg0); end
  def to_docstring; end
end
class YARD::Docstring < String
  def +(other); end
  def add_tag(*tags); end
  def all; end
  def all=(content, parse = nil); end
  def blank?(only_visible_tags = nil); end
  def convert_ref_tags; end
  def delete_tag_if(&block); end
  def delete_tags(name); end
  def dup; end
  def has_tag?(name); end
  def hash_flag; end
  def hash_flag=(v); end
  def initialize(content = nil, object = nil); end
  def line; end
  def line_range; end
  def line_range=(arg0); end
  def object; end
  def object=(arg0); end
  def parse_comments(comments); end
  def ref_tags; end
  def replace(content, parse = nil); end
  def resolve_reference; end
  def self.default_parser; end
  def self.default_parser=(arg0); end
  def self.new!(text, tags = nil, object = nil, raw_data = nil, ref_object = nil); end
  def self.parser(*args); end
  def stable_sort_by(list); end
  def summary; end
  def tag(name); end
  def tags(name = nil); end
  def to_raw; end
  def to_s; end
end
class YARD::Serializers::Base
  def after_serialize(data); end
  def before_serialize; end
  def exists?(object); end
  def initialize(opts = nil); end
  def options; end
  def serialize(object, data); end
  def serialized_path(object); end
end
class YARD::Serializers::FileSystemSerializer < YARD::Serializers::Base
  def basepath; end
  def basepath=(value); end
  def build_filename_map; end
  def encode_path_components(*components); end
  def exists?(object); end
  def extension; end
  def extension=(value); end
  def initialize(opts = nil); end
  def mapped_name(object); end
  def serialize(object, data); end
  def serialized_path(object); end
end
class YARD::StubProxy
  def _dump(_depth); end
  def hash; end
  def initialize(path, transient = nil); end
  def method_missing(meth, *args, &block); end
  def self._load(str); end
end
class YARD::Serializers::YardocSerializer < YARD::Serializers::FileSystemSerializer
  def checksums_path; end
  def complete?; end
  def complete_lock_path; end
  def deserialize(path, is_path = nil); end
  def dump(object); end
  def initialize(yfile); end
  def internal_dump(object, first_object = nil); end
  def lock_for_writing; end
  def locked_for_writing?; end
  def object_types_path; end
  def objects_path; end
  def processing_path; end
  def proxy_types_path; end
  def serialize(object); end
  def serialized_path(object); end
end
class YARD::Logger < Logger
  def <<(msg = nil); end
  def add(*args); end
  def backtrace(exc, level_meth = nil); end
  def capture(msg, nontty_log = nil); end
  def clear_line; end
  def clear_progress; end
  def debug(*args); end
  def enter_level(new_level = nil); end
  def format_log(sev, _time, _prog, msg); end
  def initialize(pipe, *args); end
  def io; end
  def io=(pipe); end
  def print(msg = nil); end
  def print_no_newline(msg); end
  def progress(msg, nontty_log = nil); end
  def puts(msg = nil); end
  def self.instance(pipe = nil); end
  def show_backtraces; end
  def show_backtraces=(arg0); end
  def show_progress; end
  def show_progress=(arg0); end
  def warn(*args); end
  def warn_no_continuations; end
  def warned; end
  def warned=(arg0); end
end
class YARD::CodeObjects::MethodObject < YARD::CodeObjects::Base
  def aliases; end
  def attr_info; end
  def constructor?; end
  def copyable_attributes; end
  def explicit; end
  def explicit=(arg0); end
  def initialize(namespace, name, scope = nil, &block); end
  def is_alias?; end
  def is_attribute?; end
  def is_explicit?; end
  def module_function?; end
  def name(prefix = nil); end
  def overridden_method; end
  def parameters; end
  def parameters=(arg0); end
  def path; end
  def reader?; end
  def scope; end
  def scope=(v); end
  def sep; end
  def writer?; end
end
class YARD::CodeObjects::ConstantObject < YARD::CodeObjects::Base
  def value; end
  def value=(value); end
end
class YARD::CodeObjects::ClassObject < YARD::CodeObjects::NamespaceObject
  def constants(opts = nil); end
  def inheritance_tree(include_mods = nil); end
  def inherited_constants; end
  def inherited_meths(opts = nil); end
  def initialize(namespace, name, *args, &block); end
  def is_exception?; end
  def meths(opts = nil); end
  def superclass; end
  def superclass=(object); end
end
class YARD::CodeObjects::ProxyMethodError < NoMethodError
end
class YARD::CodeObjects::Proxy
  def <=>(other); end
  def ==(other); end
  def ===(other); end
  def class; end
  def equal?(other); end
  def hash; end
  def initialize(namespace, name, type = nil); end
  def inspect; end
  def instance_of?(klass); end
  def is_a?(klass); end
  def kind_of?(klass); end
  def method_missing(meth, *args, &block); end
  def name(prefix = nil); end
  def namespace; end
  def parent; end
  def path; end
  def proxy_path; end
  def respond_to?(meth, include_private = nil); end
  def root?; end
  def self.===(other); end
  def title; end
  def to_ary; end
  def to_obj; end
  def to_s; end
  def to_str; end
  def type; end
  def type=(type); end
end
class YARD::CodeObjects::ClassVariableObject < YARD::CodeObjects::Base
  def value; end
  def value=(arg0); end
end
